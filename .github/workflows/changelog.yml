name: Changelog Generation

on:
    # Trigger on release tag creation (v*)
    push:
        tags:
            - "v*"

    # Allow manual workflow dispatch
    workflow_dispatch:
        inputs:
            tag:
                description: "Tag to generate changelog for (e.g., v1.2.0)"
                required: true
                type: string
            skip_release:
                description: "Skip GitHub release creation"
                required: false
                type: boolean
                default: false

permissions:
    contents: write
    pull-requests: read

jobs:
    generate-changelog:
        name: Generate Changelog
        runs-on: ubuntu-latest

        steps:
            - name: Checkout repository
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0 # Fetch all history for changelog generation

            - name: Setup Node.js
              uses: actions/setup-node@v4
              with:
                  node-version: "20"
                  cache: "npm"

            - name: Get tag information
              id: tag_info
              run: |
                  if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
                    TAG="${{ inputs.tag }}"
                  else
                    TAG="${GITHUB_REF#refs/tags/}"
                  fi
                  echo "tag=$TAG" >> $GITHUB_OUTPUT
                  echo "version=${TAG#v}" >> $GITHUB_OUTPUT

                  # Get previous tag for changelog range
                  PREVIOUS_TAG=$(git describe --tags --abbrev=0 "$TAG^" 2>/dev/null || echo "")
                  echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT

                  # Get commit range
                  if [ -n "$PREVIOUS_TAG" ]; then
                    echo "commit_range=$PREVIOUS_TAG..$TAG" >> $GITHUB_OUTPUT
                  else
                    echo "commit_range=$TAG" >> $GITHUB_OUTPUT
                  fi

            - name: Display tag information
              run: |
                  echo "Current tag: ${{ steps.tag_info.outputs.tag }}"
                  echo "Version: ${{ steps.tag_info.outputs.version }}"
                  echo "Previous tag: ${{ steps.tag_info.outputs.previous_tag }}"
                  echo "Commit range: ${{ steps.tag_info.outputs.commit_range }}"

    categorize-commits:
        name: Categorize Commits
        runs-on: ubuntu-latest
        needs: generate-changelog
        outputs:
            features: ${{ steps.categorize.outputs.features }}
            fixes: ${{ steps.categorize.outputs.fixes }}
            breaking: ${{ steps.categorize.outputs.breaking }}
            other: ${{ steps.categorize.outputs.other }}
            has_changes: ${{ steps.categorize.outputs.has_changes }}

        steps:
            - name: Checkout repository
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: Get tag information
              id: tag_info
              run: |
                  if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
                    TAG="${{ inputs.tag }}"
                  else
                    TAG="${GITHUB_REF#refs/tags/}"
                  fi
                  echo "tag=$TAG" >> $GITHUB_OUTPUT

                  # Get previous tag
                  PREVIOUS_TAG=$(git describe --tags --abbrev=0 "$TAG^" 2>/dev/null || echo "")
                  echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT

                  # Get commit range
                  if [ -n "$PREVIOUS_TAG" ]; then
                    echo "commit_range=$PREVIOUS_TAG..$TAG" >> $GITHUB_OUTPUT
                  else
                    # If no previous tag, get all commits up to this tag
                    FIRST_COMMIT=$(git rev-list --max-parents=0 HEAD)
                    echo "commit_range=$FIRST_COMMIT..$TAG" >> $GITHUB_OUTPUT
                  fi

            - name: Categorize commits by conventional commit format
              id: categorize
              run: |
                  # Initialize arrays
                  FEATURES=""
                  FIXES=""
                  BREAKING=""
                  OTHER=""

                  # Get commits in range
                  COMMIT_RANGE="${{ steps.tag_info.outputs.commit_range }}"

                  # Parse commits and categorize
                  while IFS= read -r commit; do
                    # Get commit hash and message
                    HASH=$(echo "$commit" | cut -d' ' -f1)
                    MESSAGE=$(echo "$commit" | cut -d' ' -f2-)
                    
                    # Check for breaking changes
                    if echo "$MESSAGE" | grep -qE "^[a-z]+(\([a-z-]+\))?!:"; then
                      BREAKING="${BREAKING}- ${MESSAGE} (${HASH:0:7})\n"
                    # Check for features
                    elif echo "$MESSAGE" | grep -qE "^feat(\([a-z-]+\))?:"; then
                      FEATURES="${FEATURES}- ${MESSAGE#feat*: } (${HASH:0:7})\n"
                    # Check for fixes
                    elif echo "$MESSAGE" | grep -qE "^fix(\([a-z-]+\))?:"; then
                      FIXES="${FIXES}- ${MESSAGE#fix*: } (${HASH:0:7})\n"
                    # Check for other conventional commit types
                    elif echo "$MESSAGE" | grep -qE "^(docs|style|refactor|perf|test|build|ci|chore)(\([a-z-]+\))?:"; then
                      TYPE=$(echo "$MESSAGE" | sed -E 's/^([a-z]+)(\([a-z-]+\))?:.*/\1/')
                      OTHER="${OTHER}- [${TYPE}] ${MESSAGE#*: } (${HASH:0:7})\n"
                    else
                      # Non-conventional commits
                      OTHER="${OTHER}- ${MESSAGE} (${HASH:0:7})\n"
                    fi
                  done < <(git log --pretty=format:"%H %s" "$COMMIT_RANGE")

                  # Check if we have any changes
                  HAS_CHANGES="false"
                  if [ -n "$FEATURES" ] || [ -n "$FIXES" ] || [ -n "$BREAKING" ] || [ -n "$OTHER" ]; then
                    HAS_CHANGES="true"
                  fi

                  # Output to GitHub Actions (escape newlines)
                  echo "features<<EOF" >> $GITHUB_OUTPUT
                  echo -e "$FEATURES" >> $GITHUB_OUTPUT
                  echo "EOF" >> $GITHUB_OUTPUT

                  echo "fixes<<EOF" >> $GITHUB_OUTPUT
                  echo -e "$FIXES" >> $GITHUB_OUTPUT
                  echo "EOF" >> $GITHUB_OUTPUT

                  echo "breaking<<EOF" >> $GITHUB_OUTPUT
                  echo -e "$BREAKING" >> $GITHUB_OUTPUT
                  echo "EOF" >> $GITHUB_OUTPUT

                  echo "other<<EOF" >> $GITHUB_OUTPUT
                  echo -e "$OTHER" >> $GITHUB_OUTPUT
                  echo "EOF" >> $GITHUB_OUTPUT

                  echo "has_changes=$HAS_CHANGES" >> $GITHUB_OUTPUT

            - name: Display categorized commits
              run: |
                  echo "=== Features ==="
                  echo "${{ steps.categorize.outputs.features }}"
                  echo ""
                  echo "=== Fixes ==="
                  echo "${{ steps.categorize.outputs.fixes }}"
                  echo ""
                  echo "=== Breaking Changes ==="
                  echo "${{ steps.categorize.outputs.breaking }}"
                  echo ""
                  echo "=== Other Changes ==="
                  echo "${{ steps.categorize.outputs.other }}"

    create-release:
        name: Create GitHub Release
        runs-on: ubuntu-latest
        needs: categorize-commits
        if: |
            needs.categorize-commits.outputs.has_changes == 'true' &&
            (github.event_name != 'workflow_dispatch' || !inputs.skip_release)

        steps:
            - name: Checkout repository
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: Get tag information
              id: tag_info
              run: |
                  if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
                    TAG="${{ inputs.tag }}"
                  else
                    TAG="${GITHUB_REF#refs/tags/}"
                  fi
                  echo "tag=$TAG" >> $GITHUB_OUTPUT
                  echo "version=${TAG#v}" >> $GITHUB_OUTPUT

                  # Get tag date
                  TAG_DATE=$(git log -1 --format=%ai "$TAG")
                  echo "date=$TAG_DATE" >> $GITHUB_OUTPUT

            - name: Generate changelog content
              id: changelog
              run: |
                  TAG="${{ steps.tag_info.outputs.tag }}"
                  VERSION="${{ steps.tag_info.outputs.version }}"
                  DATE="${{ steps.tag_info.outputs.date }}"

                  # Start changelog
                  CHANGELOG="# Release $TAG\n\n"
                  CHANGELOG="${CHANGELOG}**Release Date:** $(date -d "$DATE" '+%Y-%m-%d')\n\n"

                  # Add breaking changes if any
                  BREAKING="${{ needs.categorize-commits.outputs.breaking }}"
                  if [ -n "$BREAKING" ]; then
                    CHANGELOG="${CHANGELOG}## âš ï¸ Breaking Changes\n\n$BREAKING\n"
                  fi

                  # Add features if any
                  FEATURES="${{ needs.categorize-commits.outputs.features }}"
                  if [ -n "$FEATURES" ]; then
                    CHANGELOG="${CHANGELOG}## âœ¨ Features\n\n$FEATURES\n"
                  fi

                  # Add fixes if any
                  FIXES="${{ needs.categorize-commits.outputs.fixes }}"
                  if [ -n "$FIXES" ]; then
                    CHANGELOG="${CHANGELOG}## ðŸ› Bug Fixes\n\n$FIXES\n"
                  fi

                  # Add other changes if any
                  OTHER="${{ needs.categorize-commits.outputs.other }}"
                  if [ -n "$OTHER" ]; then
                    CHANGELOG="${CHANGELOG}## ðŸ“ Other Changes\n\n$OTHER\n"
                  fi

                  # Save to file
                  echo -e "$CHANGELOG" > release-notes.md

                  # Output for GitHub release
                  echo "content<<EOF" >> $GITHUB_OUTPUT
                  cat release-notes.md >> $GITHUB_OUTPUT
                  echo "EOF" >> $GITHUB_OUTPUT

            - name: Create GitHub Release
              uses: actions/create-release@v1
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              with:
                  tag_name: ${{ steps.tag_info.outputs.tag }}
                  release_name: Release ${{ steps.tag_info.outputs.tag }}
                  body: ${{ steps.changelog.outputs.content }}
                  draft: false
                  prerelease: false

            - name: Upload release notes as artifact
              uses: actions/upload-artifact@v4
              with:
                  name: release-notes
                  path: release-notes.md
                  retention-days: 90

    update-changelog-file:
        name: Update CHANGELOG.md
        runs-on: ubuntu-latest
        needs: [categorize-commits, create-release]
        if: needs.categorize-commits.outputs.has_changes == 'true'

        steps:
            - name: Checkout repository
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0
                  token: ${{ secrets.GITHUB_TOKEN }}

            - name: Configure Git
              run: |
                  git config user.name "github-actions[bot]"
                  git config user.email "github-actions[bot]@users.noreply.github.com"

            - name: Get tag information
              id: tag_info
              run: |
                  if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
                    TAG="${{ inputs.tag }}"
                  else
                    TAG="${GITHUB_REF#refs/tags/}"
                  fi
                  echo "tag=$TAG" >> $GITHUB_OUTPUT
                  echo "version=${TAG#v}" >> $GITHUB_OUTPUT

                  # Get tag date
                  TAG_DATE=$(git log -1 --format=%ai "$TAG")
                  echo "date=$(date -d "$TAG_DATE" '+%Y-%m-%d')" >> $GITHUB_OUTPUT

            - name: Update CHANGELOG.md
              run: |
                  TAG="${{ steps.tag_info.outputs.tag }}"
                  VERSION="${{ steps.tag_info.outputs.version }}"
                  DATE="${{ steps.tag_info.outputs.date }}"

                  # Create new changelog entry
                  NEW_ENTRY="## [$VERSION] - $DATE\n\n"

                  # Add breaking changes if any
                  BREAKING="${{ needs.categorize-commits.outputs.breaking }}"
                  if [ -n "$BREAKING" ]; then
                    NEW_ENTRY="${NEW_ENTRY}### âš ï¸ Breaking Changes\n\n$BREAKING\n"
                  fi

                  # Add features if any
                  FEATURES="${{ needs.categorize-commits.outputs.features }}"
                  if [ -n "$FEATURES" ]; then
                    NEW_ENTRY="${NEW_ENTRY}### âœ¨ Features\n\n$FEATURES\n"
                  fi

                  # Add fixes if any
                  FIXES="${{ needs.categorize-commits.outputs.fixes }}"
                  if [ -n "$FIXES" ]; then
                    NEW_ENTRY="${NEW_ENTRY}### ðŸ› Bug Fixes\n\n$FIXES\n"
                  fi

                  # Add other changes if any
                  OTHER="${{ needs.categorize-commits.outputs.other }}"
                  if [ -n "$OTHER" ]; then
                    NEW_ENTRY="${NEW_ENTRY}### ðŸ“ Other Changes\n\n$OTHER\n"
                  fi

                  # Check if CHANGELOG.md exists
                  if [ ! -f CHANGELOG.md ]; then
                    echo "# Changelog" > CHANGELOG.md
                    echo "" >> CHANGELOG.md
                    echo "All notable changes to this project will be documented in this file." >> CHANGELOG.md
                    echo "" >> CHANGELOG.md
                    echo "The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/)," >> CHANGELOG.md
                    echo "and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html)." >> CHANGELOG.md
                    echo "" >> CHANGELOG.md
                  fi

                  # Insert new entry after the header
                  # Find the line number after the header (after "# Changelog" and description)
                  LINE_NUM=$(grep -n "^## \[" CHANGELOG.md | head -1 | cut -d: -f1)

                  if [ -z "$LINE_NUM" ]; then
                    # No previous releases, append to end
                    echo -e "\n$NEW_ENTRY" >> CHANGELOG.md
                  else
                    # Insert before first release entry
                    {
                      head -n $((LINE_NUM - 1)) CHANGELOG.md
                      echo -e "$NEW_ENTRY"
                      tail -n +$LINE_NUM CHANGELOG.md
                    } > CHANGELOG.md.tmp
                    mv CHANGELOG.md.tmp CHANGELOG.md
                  fi

            - name: Commit and push CHANGELOG.md
              run: |
                  git add CHANGELOG.md
                  git commit -m "chore: update CHANGELOG.md for ${{ steps.tag_info.outputs.tag }}"
                  git push origin HEAD:main || git push origin HEAD:master || echo "Could not push to main/master branch"

            - name: Upload updated CHANGELOG.md as artifact
              uses: actions/upload-artifact@v4
              with:
                  name: changelog
                  path: CHANGELOG.md
                  retention-days: 90

    bump-version:
        name: Bump Version
        runs-on: ubuntu-latest
        needs: categorize-commits
        if: needs.categorize-commits.outputs.has_changes == 'true'

        steps:
            - name: Checkout repository
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: Get tag information
              id: tag_info
              run: |
                  if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
                    TAG="${{ inputs.tag }}"
                  else
                    TAG="${GITHUB_REF#refs/tags/}"
                  fi
                  echo "tag=$TAG" >> $GITHUB_OUTPUT
                  echo "version=${TAG#v}" >> $GITHUB_OUTPUT

            - name: Determine version bump type
              id: bump_type
              run: |
                  BREAKING="${{ needs.categorize-commits.outputs.breaking }}"
                  FEATURES="${{ needs.categorize-commits.outputs.features }}"

                  if [ -n "$BREAKING" ]; then
                    echo "type=major" >> $GITHUB_OUTPUT
                    echo "description=Breaking changes detected" >> $GITHUB_OUTPUT
                  elif [ -n "$FEATURES" ]; then
                    echo "type=minor" >> $GITHUB_OUTPUT
                    echo "description=New features added" >> $GITHUB_OUTPUT
                  else
                    echo "type=patch" >> $GITHUB_OUTPUT
                    echo "description=Bug fixes and improvements" >> $GITHUB_OUTPUT
                  fi

            - name: Calculate next version
              id: next_version
              run: |
                  CURRENT_VERSION="${{ steps.tag_info.outputs.version }}"
                  BUMP_TYPE="${{ steps.bump_type.outputs.type }}"

                  # Parse version (assuming semver: major.minor.patch)
                  IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

                  # Remove any pre-release or build metadata
                  PATCH=$(echo "$PATCH" | cut -d'-' -f1 | cut -d'+' -f1)

                  # Bump version based on type
                  case "$BUMP_TYPE" in
                    major)
                      MAJOR=$((MAJOR + 1))
                      MINOR=0
                      PATCH=0
                      ;;
                    minor)
                      MINOR=$((MINOR + 1))
                      PATCH=0
                      ;;
                    patch)
                      PATCH=$((PATCH + 1))
                      ;;
                  esac

                  NEXT_VERSION="$MAJOR.$MINOR.$PATCH"
                  echo "version=$NEXT_VERSION" >> $GITHUB_OUTPUT
                  echo "tag=v$NEXT_VERSION" >> $GITHUB_OUTPUT

            - name: Display version information
              run: |
                  echo "Current version: ${{ steps.tag_info.outputs.version }}"
                  echo "Bump type: ${{ steps.bump_type.outputs.type }}"
                  echo "Reason: ${{ steps.bump_type.outputs.description }}"
                  echo "Next version: ${{ steps.next_version.outputs.version }}"
                  echo "Next tag: ${{ steps.next_version.outputs.tag }}"
                  echo ""
                  echo "To create the next release, run:"
                  echo "  git tag ${{ steps.next_version.outputs.tag }}"
                  echo "  git push origin ${{ steps.next_version.outputs.tag }}"

    notify:
        name: Send Notifications
        runs-on: ubuntu-latest
        needs: [categorize-commits, create-release, update-changelog-file]
        if: always() && needs.categorize-commits.outputs.has_changes == 'true'

        steps:
            - name: Get tag information
              id: tag_info
              run: |
                  if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
                    TAG="${{ inputs.tag }}"
                  else
                    TAG="${GITHUB_REF#refs/tags/}"
                  fi
                  echo "tag=$TAG" >> $GITHUB_OUTPUT

            - name: Determine workflow status
              id: status
              run: |
                  if [ "${{ needs.create-release.result }}" = "success" ] && [ "${{ needs.update-changelog-file.result }}" = "success" ]; then
                    echo "status=success" >> $GITHUB_OUTPUT
                    echo "emoji=âœ…" >> $GITHUB_OUTPUT
                    echo "color=good" >> $GITHUB_OUTPUT
                  else
                    echo "status=failure" >> $GITHUB_OUTPUT
                    echo "emoji=âŒ" >> $GITHUB_OUTPUT
                    echo "color=danger" >> $GITHUB_OUTPUT
                  fi

            - name: Send Slack notification
              if: env.SLACK_WEBHOOK_URL != ''
              env:
                  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
              run: |
                  STATUS="${{ steps.status.outputs.status }}"
                  EMOJI="${{ steps.status.outputs.emoji }}"
                  TAG="${{ steps.tag_info.outputs.tag }}"

                  if [ "$STATUS" = "success" ]; then
                    MESSAGE="$EMOJI Changelog generated successfully for release $TAG"
                    DETAILS="GitHub release created and CHANGELOG.md updated"
                  else
                    MESSAGE="$EMOJI Changelog generation failed for release $TAG"
                    DETAILS="Check workflow logs for details"
                  fi

                  curl -X POST "$SLACK_WEBHOOK_URL" \
                    -H 'Content-Type: application/json' \
                    -d "{
                      \"text\": \"$MESSAGE\",
                      \"attachments\": [{
                        \"color\": \"${{ steps.status.outputs.color }}\",
                        \"fields\": [
                          {
                            \"title\": \"Release\",
                            \"value\": \"$TAG\",
                            \"short\": true
                          },
                          {
                            \"title\": \"Status\",
                            \"value\": \"$STATUS\",
                            \"short\": true
                          },
                          {
                            \"title\": \"Details\",
                            \"value\": \"$DETAILS\",
                            \"short\": false
                          }
                        ]
                      }]
                    }" || echo "Slack notification failed (webhook may not be configured)"
