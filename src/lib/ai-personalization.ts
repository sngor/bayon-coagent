/**
 * AI Personalization Engine
 * 
 * Tracks user behavior, learns patterns, and provides AI-powered personalization
 * for the real estate agent marketing platform. Uses DynamoDB for storage and
 * AWS Bedrock for AI-powered insights and recommendations.
 */

import { getRepository } from '@/aws/dynamodb/repository';
import { getBedrockClient } from '@/aws/bedrock/client';
import { EntityType } from '@/aws/dynamodb/types';
import { z } from 'zod';

/**
 * Entity type for personalization data
 */
const PERSONALIZATION_ENTITY_TYPE: EntityType = 'PersonalizationProfile';

/**
 * Personalization profile stored in DynamoDB
 */
export interface PersonalizationProfile {
  userId: string;
  marketFocus: string[];
  frequentFeatures: Record<string, number>;
  contentPreferences: {
    preferredContentTypes: string[];
    optimalPostingTimes: string[];
    audienceInsights: Record<string, any>;
  };
  workflowPatterns: {
    commonSequences: string[][];
    timeOfDayUsage: Record<string, number>;
    lastUsedFeatures: Array<{
      feature: string;
      timestamp: number;
    }>;
  };
  goals: {
    shortTerm: string[];
    longTerm: string[];
    progress: Record<string, number>;
  };
  lastUpdated: number;
}

/**
 * Priority action suggested by AI
 */
export interface PriorityAction {
  title: string;
  description: string;
  reason: string;
  href: string;
  priority: 'high' | 'medium' | 'low';
  estimatedTime?: string;
}

/**
 * Market insight generated by AI
 */
export interface MarketInsight {
  title: string;
  description: string;
  category: 'opportunity' | 'warning' | 'trend' | 'tip';
  actionable: boolean;
  relatedFeatures?: string[];
}

/**
 * Personalized dashboard data
 */
export interface PersonalizedDashboard {
  priorityActions: PriorityAction[];
  suggestedContent: Array<{
    type: string;
    title: string;
    description: string;
  }>;
  marketInsights: MarketInsight[];
  nextBestActions: Array<{
    action: string;
    context: string;
  }>;
}

/**
 * AI suggestion context
 */
export interface SuggestionContext {
  currentPage?: string;
  recentActions?: string[];
  timeOfDay?: number;
  profileCompletion?: number;
}

/**
 * Zod schema for AI-generated suggestions
 */
const AISuggestionsSchema = z.object({
  suggestions: z.array(
    z.object({
      title: z.string(),
      description: z.string(),
      action: z.string(),
      priority: z.enum(['high', 'medium', 'low']),
    })
  ),
});

/**
 * Zod schema for AI-generated priority actions
 */
const PriorityActionsSchema = z.object({
  actions: z.array(
    z.object({
      title: z.string(),
      description: z.string(),
      reason: z.string(),
      href: z.string(),
      priority: z.enum(['high', 'medium', 'low']),
      estimatedTime: z.string().optional(),
    })
  ),
});

/**
 * Zod schema for AI-generated market insights
 */
const MarketInsightsSchema = z.object({
  insights: z.array(
    z.object({
      title: z.string(),
      description: z.string(),
      category: z.enum(['opportunity', 'warning', 'trend', 'tip']),
      actionable: z.boolean(),
      relatedFeatures: z.array(z.string()).optional(),
    })
  ),
});

/**
 * AI Personalization Engine
 * 
 * Provides methods for tracking user behavior, learning patterns,
 * and generating AI-powered personalized recommendations.
 */
export class AIPersonalizationEngine {
  private repository = getRepository();
  private bedrockClient = getBedrockClient();

  /**
   * Generates DynamoDB keys for personalization profile
   */
  private getPersonalizationKeys(userId: string) {
    return {
      PK: `USER#${userId}`,
      SK: 'PERSONALIZATION',
    };
  }

  /**
   * Gets the personalization profile for a user
   * Creates a default profile if one doesn't exist
   */
  async getProfile(userId: string): Promise<PersonalizationProfile> {
    const keys = this.getPersonalizationKeys(userId);
    const profile = await this.repository.get<PersonalizationProfile>(
      keys.PK,
      keys.SK
    );

    if (profile) {
      return profile;
    }

    // Create default profile
    const defaultProfile: PersonalizationProfile = {
      userId,
      marketFocus: [],
      frequentFeatures: {},
      contentPreferences: {
        preferredContentTypes: [],
        optimalPostingTimes: [],
        audienceInsights: {},
      },
      workflowPatterns: {
        commonSequences: [],
        timeOfDayUsage: {},
        lastUsedFeatures: [],
      },
      goals: {
        shortTerm: [],
        longTerm: [],
        progress: {},
      },
      lastUpdated: Date.now(),
    };

    await this.repository.create(
      keys.PK,
      keys.SK,
      PERSONALIZATION_ENTITY_TYPE,
      defaultProfile
    );

    return defaultProfile;
  }

  /**
   * Updates the personalization profile
   */
  async updateProfile(
    userId: string,
    updates: Partial<PersonalizationProfile>
  ): Promise<void> {
    const keys = this.getPersonalizationKeys(userId);
    await this.repository.update(keys.PK, keys.SK, {
      ...updates,
      lastUpdated: Date.now(),
    });
  }

  /**
   * Tracks feature usage for a user
   * Updates frequency counts and usage patterns
   */
  async trackFeatureUsage(userId: string, feature: string): Promise<void> {
    const profile = await this.getProfile(userId);

    // Update feature frequency
    const frequentFeatures = { ...profile.frequentFeatures };
    frequentFeatures[feature] = (frequentFeatures[feature] || 0) + 1;

    // Update time of day usage
    const hour = new Date().getHours();
    const timeOfDayUsage = { ...profile.workflowPatterns.timeOfDayUsage };
    timeOfDayUsage[hour.toString()] =
      (timeOfDayUsage[hour.toString()] || 0) + 1;

    // Update last used features (keep last 20)
    const lastUsedFeatures = [
      { feature, timestamp: Date.now() },
      ...profile.workflowPatterns.lastUsedFeatures,
    ].slice(0, 20);

    // Detect common sequences (last 5 features)
    const recentFeatures = lastUsedFeatures.slice(0, 5).map((f) => f.feature);
    const commonSequences = this.updateCommonSequences(
      profile.workflowPatterns.commonSequences,
      recentFeatures
    );

    await this.updateProfile(userId, {
      frequentFeatures,
      workflowPatterns: {
        ...profile.workflowPatterns,
        timeOfDayUsage,
        lastUsedFeatures,
        commonSequences,
      },
    });
  }

  /**
   * Updates common workflow sequences
   */
  private updateCommonSequences(
    existingSequences: string[][],
    recentFeatures: string[]
  ): string[][] {
    // Add new sequence if it's not already tracked
    const sequenceKey = recentFeatures.join('->');
    const exists = existingSequences.some(
      (seq) => seq.join('->') === sequenceKey
    );

    if (!exists && recentFeatures.length >= 2) {
      return [...existingSequences, recentFeatures].slice(-10); // Keep last 10 sequences
    }

    return existingSequences;
  }

  /**
   * Gets personalized dashboard data with AI-powered recommendations
   */
  async getPersonalizedDashboard(
    userId: string
  ): Promise<PersonalizedDashboard> {
    const profile = await this.getProfile(userId);

    // Generate AI-powered priority actions
    const priorityActions = await this.getAIPriorityActions(profile);

    // Generate content suggestions
    const suggestedContent = await this.getAISuggestedContent(profile);

    // Generate market insights
    const marketInsights = await this.getMarketInsights(profile);

    // Generate next best actions
    const nextBestActions = await this.getNextBestActions(profile);

    return {
      priorityActions,
      suggestedContent,
      marketInsights,
      nextBestActions,
    };
  }

  /**
   * Generates AI-powered priority actions based on user profile
   */
  async getAIPriorityActions(
    profile: PersonalizationProfile
  ): Promise<PriorityAction[]> {
    try {
      const prompt = this.buildPriorityActionsPrompt(profile);

      const result = await this.bedrockClient.invoke(
        prompt,
        PriorityActionsSchema,
        {
          temperature: 0.7,
          maxTokens: 2000,
        }
      );

      return result.actions;
    } catch (error) {
      console.error('Failed to generate priority actions:', error);
      // Return fallback actions based on frequent features
      return this.getFallbackPriorityActions(profile);
    }
  }

  /**
   * Builds prompt for AI priority actions
   */
  private buildPriorityActionsPrompt(
    profile: PersonalizationProfile
  ): string {
    const frequentFeatures = Object.entries(profile.frequentFeatures)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 5)
      .map(([feature]) => feature);

    return `You are an AI assistant helping a real estate agent optimize their marketing workflow.

User Profile:
- Market Focus: ${profile.marketFocus.join(', ') || 'Not specified'}
- Frequently Used Features: ${frequentFeatures.join(', ') || 'None yet'}
- Short-term Goals: ${profile.goals.shortTerm.join(', ') || 'Not specified'}
- Long-term Goals: ${profile.goals.longTerm.join(', ') || 'Not specified'}

Based on this profile, suggest 3-5 priority actions the agent should take today to improve their marketing effectiveness.
Each action should be specific, actionable, and aligned with their goals and usage patterns.

Return your response as JSON matching this structure:
{
  "actions": [
    {
      "title": "Action title",
      "description": "Brief description",
      "reason": "Why this action is important now",
      "href": "/path/to/feature",
      "priority": "high" | "medium" | "low",
      "estimatedTime": "5 minutes" (optional)
    }
  ]
}`;
  }

  /**
   * Gets fallback priority actions when AI is unavailable
   */
  private getFallbackPriorityActions(
    profile: PersonalizationProfile
  ): PriorityAction[] {
    const actions: PriorityAction[] = [];

    // Suggest based on frequent features
    const topFeatures = Object.entries(profile.frequentFeatures)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 3);

    if (topFeatures.length === 0) {
      // New user - suggest getting started
      actions.push({
        title: 'Complete Your Profile',
        description: 'Add your market focus and professional details',
        reason: 'A complete profile helps us provide better recommendations',
        href: '/profile',
        priority: 'high',
        estimatedTime: '5 minutes',
      });
    } else {
      // Suggest continuing with frequent features
      topFeatures.forEach(([feature]) => {
        actions.push({
          title: `Continue with ${feature}`,
          description: `You've been using this feature frequently`,
          reason: 'Build on your momentum',
          href: `/${feature.toLowerCase().replace(/\s+/g, '-')}`,
          priority: 'medium',
        });
      });
    }

    return actions;
  }

  /**
   * Generates AI-suggested content based on user preferences
   */
  async getAISuggestedContent(profile: PersonalizationProfile): Promise<
    Array<{
      type: string;
      title: string;
      description: string;
    }>
  > {
    // Return content suggestions based on preferences
    const preferredTypes = profile.contentPreferences.preferredContentTypes;

    if (preferredTypes.length === 0) {
      return [
        {
          type: 'blog-post',
          title: 'Write a Blog Post',
          description: 'Share your expertise with potential clients',
        },
        {
          type: 'social-media',
          title: 'Create Social Media Content',
          description: 'Engage your audience on social platforms',
        },
      ];
    }

    return preferredTypes.slice(0, 3).map((type) => ({
      type,
      title: `Create ${type.replace(/-/g, ' ')}`,
      description: `You've had success with this content type`,
    }));
  }

  /**
   * Generates market insights based on user's market focus
   */
  async getMarketInsights(
    profile: PersonalizationProfile
  ): Promise<MarketInsight[]> {
    try {
      const prompt = this.buildMarketInsightsPrompt(profile);

      const result = await this.bedrockClient.invoke(
        prompt,
        MarketInsightsSchema,
        {
          temperature: 0.7,
          maxTokens: 1500,
        }
      );

      return result.insights;
    } catch (error) {
      console.error('Failed to generate market insights:', error);
      return this.getFallbackMarketInsights(profile);
    }
  }

  /**
   * Builds prompt for market insights
   */
  private buildMarketInsightsPrompt(profile: PersonalizationProfile): string {
    return `You are an AI assistant providing market insights for a real estate agent.

User's Market Focus: ${profile.marketFocus.join(', ') || 'General real estate'}

Provide 2-3 actionable market insights that would be valuable for this agent.
Focus on opportunities, trends, or tips relevant to their market.

Return your response as JSON matching this structure:
{
  "insights": [
    {
      "title": "Insight title",
      "description": "Detailed description",
      "category": "opportunity" | "warning" | "trend" | "tip",
      "actionable": true | false,
      "relatedFeatures": ["feature1", "feature2"] (optional)
    }
  ]
}`;
  }

  /**
   * Gets fallback market insights
   */
  private getFallbackMarketInsights(
    profile: PersonalizationProfile
  ): MarketInsight[] {
    return [
      {
        title: 'Optimize Your Online Presence',
        description:
          'Ensure your NAP (Name, Address, Phone) is consistent across all platforms',
        category: 'tip',
        actionable: true,
        relatedFeatures: ['brand-audit'],
      },
      {
        title: 'Content Marketing Opportunity',
        description:
          'Regular content creation can significantly boost your visibility',
        category: 'opportunity',
        actionable: true,
        relatedFeatures: ['content-engine'],
      },
    ];
  }

  /**
   * Predicts next best actions based on workflow patterns
   */
  async getNextBestActions(
    profile: PersonalizationProfile
  ): Promise<Array<{ action: string; context: string }>> {
    const actions: Array<{ action: string; context: string }> = [];

    // Analyze common sequences
    if (profile.workflowPatterns.commonSequences.length > 0) {
      const lastFeature =
        profile.workflowPatterns.lastUsedFeatures[0]?.feature;

      if (lastFeature) {
        // Find sequences that start with the last feature
        const matchingSequences = profile.workflowPatterns.commonSequences.filter(
          (seq) => seq[0] === lastFeature
        );

        if (matchingSequences.length > 0) {
          const nextFeature = matchingSequences[0][1];
          actions.push({
            action: nextFeature,
            context: `You typically use ${nextFeature} after ${lastFeature}`,
          });
        }
      }
    }

    // Suggest based on time of day
    const hour = new Date().getHours();
    const timeOfDayUsage = profile.workflowPatterns.timeOfDayUsage;
    const currentHourUsage = timeOfDayUsage[hour.toString()] || 0;

    if (currentHourUsage > 5) {
      actions.push({
        action: 'Continue your workflow',
        context: `You're typically productive at this time`,
      });
    }

    return actions;
  }

  /**
   * Gets AI-powered contextual suggestions
   */
  async getAISuggestions(
    userId: string,
    context: SuggestionContext
  ): Promise<
    Array<{
      title: string;
      description: string;
      action: string;
      priority: 'high' | 'medium' | 'low';
    }>
  > {
    try {
      const profile = await this.getProfile(userId);
      const prompt = this.buildSuggestionsPrompt(profile, context);

      const result = await this.bedrockClient.invoke(
        prompt,
        AISuggestionsSchema,
        {
          temperature: 0.7,
          maxTokens: 1500,
        }
      );

      return result.suggestions;
    } catch (error) {
      console.error('Failed to generate AI suggestions:', error);
      return [];
    }
  }

  /**
   * Builds prompt for contextual suggestions
   */
  private buildSuggestionsPrompt(
    profile: PersonalizationProfile,
    context: SuggestionContext
  ): string {
    return `You are an AI assistant helping a real estate agent with their marketing workflow.

User Profile:
- Market Focus: ${profile.marketFocus.join(', ') || 'Not specified'}
- Recent Actions: ${context.recentActions?.join(', ') || 'None'}
- Current Page: ${context.currentPage || 'Unknown'}
- Time of Day: ${context.timeOfDay || new Date().getHours()}
- Profile Completion: ${context.profileCompletion || 0}%

Provide 2-3 contextual suggestions for what the agent should do next.
Consider their current context and make suggestions that are immediately actionable.

Return your response as JSON matching this structure:
{
  "suggestions": [
    {
      "title": "Suggestion title",
      "description": "Brief description",
      "action": "Specific action to take",
      "priority": "high" | "medium" | "low"
    }
  ]
}`;
  }

  /**
   * Tracks content preferences based on user actions
   */
  async trackContentPreference(
    userId: string,
    contentType: string,
    success: boolean
  ): Promise<void> {
    const profile = await this.getProfile(userId);

    if (success) {
      const preferredTypes = [
        ...new Set([
          contentType,
          ...profile.contentPreferences.preferredContentTypes,
        ]),
      ].slice(0, 10);

      await this.updateProfile(userId, {
        contentPreferences: {
          ...profile.contentPreferences,
          preferredContentTypes: preferredTypes,
        },
      });
    }
  }

  /**
   * Updates user goals
   */
  async updateGoals(
    userId: string,
    goals: {
      shortTerm?: string[];
      longTerm?: string[];
    }
  ): Promise<void> {
    const profile = await this.getProfile(userId);

    await this.updateProfile(userId, {
      goals: {
        ...profile.goals,
        ...goals,
      },
    });
  }

  /**
   * Updates market focus
   */
  async updateMarketFocus(
    userId: string,
    marketFocus: string[]
  ): Promise<void> {
    await this.updateProfile(userId, {
      marketFocus,
    });
  }

  /**
   * Gets frequently used features
   */
  async getFrequentFeatures(userId: string): Promise<string[]> {
    const profile = await this.getProfile(userId);

    return Object.entries(profile.frequentFeatures)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 5)
      .map(([feature]) => feature);
  }
}

/**
 * Singleton instance
 */
let engineInstance: AIPersonalizationEngine | null = null;

/**
 * Gets the singleton AI personalization engine instance
 */
export function getPersonalizationEngine(): AIPersonalizationEngine {
  if (!engineInstance) {
    engineInstance = new AIPersonalizationEngine();
  }
  return engineInstance;
}

/**
 * Resets the singleton instance (useful for testing)
 */
export function resetPersonalizationEngine(): void {
  engineInstance = null;
}
