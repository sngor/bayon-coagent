/**
 * AI Visibility Export Format Utilities
 * 
 * Utility functions for exporting schema data in multiple formats
 * Requirements: 8.1, 8.2, 8.3, 8.4, 8.5
 */

import type {
  SchemaMarkup,
  ExportPackage,
  ExportFormat,
  RDFTriple,
} from '../types';

/**
 * Converts schema markup to JSON-LD format
 */
export function toJSONLD(schemas: SchemaMarkup[]): string {
  if (schemas.length === 0) {
    return JSON.stringify({}, null, 2);
  }

  if (schemas.length === 1) {
    return JSON.stringify(schemas[0], null, 2);
  }

  // Multiple schemas - wrap in array
  return JSON.stringify(schemas, null, 2);
}

/**
 * Converts schema markup to RDF/XML format with proper namespace declarations
 * Requirements: 2.3, 8.3
 */
export function toRDFXML(schemas: SchemaMarkup[]): string {
  const namespaces = `
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
    xmlns:schema="https://schema.org/"
    xmlns:owl="http://www.w3.org/2002/07/owl#"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema#"
    xmlns:foaf="http://xmlns.com/foaf/0.1/"
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:dcterms="http://purl.org/dc/terms/"
    xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"
    xmlns:vcard="http://www.w3.org/2006/vcard/ns#"
  `.trim();

  let rdfContent = `<?xml version="1.0" encoding="UTF-8"?>\n`;
  rdfContent += `<rdf:RDF ${namespaces}>\n\n`;
  
  // Add ontology references and metadata
  rdfContent += `  <!-- Ontology References -->\n`;
  rdfContent += `  <owl:Ontology rdf:about="">\n`;
  rdfContent += `    <rdfs:label>Real Estate Agent Knowledge Graph</rdfs:label>\n`;
  rdfContent += `    <rdfs:comment>AI Visibility Optimization Schema Markup for Real Estate Agents</rdfs:comment>\n`;
  rdfContent += `    <owl:imports rdf:resource="https://schema.org/"/>\n`;
  rdfContent += `    <dcterms:created rdf:datatype="xsd:dateTime">${new Date().toISOString()}</dcterms:created>\n`;
  rdfContent += `    <dcterms:creator>Bayon Coagent AI Visibility System</dcterms:creator>\n`;
  rdfContent += `  </owl:Ontology>\n\n`;

  for (const schema of schemas) {
    rdfContent += schemaToRDFXML(schema);
  }

  rdfContent += `</rdf:RDF>\n`;
  return rdfContent;
}

/**
 * Converts a single schema to RDF/XML
 */
function schemaToRDFXML(schema: SchemaMarkup): string {
  const id = schema['@id'] || `#${schema['@type'].toLowerCase()}`;
  let rdf = `  <schema:${schema['@type']} rdf:about="${id}">\n`;

  // Add properties
  Object.entries(schema).forEach(([key, value]) => {
    if (key.startsWith('@') || !value) return;

    if (typeof value === 'string') {
      rdf += `    <schema:${key}>${escapeXML(value)}</schema:${key}>\n`;
    } else if (typeof value === 'object' && !Array.isArray(value)) {
      // Nested object
      if (value['@type']) {
        rdf += `    <schema:${key}>\n`;
        rdf += `      <schema:${value['@type']}>\n`;
        Object.entries(value).forEach(([nestedKey, nestedValue]) => {
          if (nestedKey.startsWith('@') || !nestedValue) return;
          rdf += `        <schema:${nestedKey}>${escapeXML(String(nestedValue))}</schema:${nestedKey}>\n`;
        });
        rdf += `      </schema:${value['@type']}>\n`;
        rdf += `    </schema:${key}>\n`;
      }
    } else if (Array.isArray(value)) {
      // Array of values
      value.forEach(item => {
        if (typeof item === 'string') {
          rdf += `    <schema:${key}>${escapeXML(item)}</schema:${key}>\n`;
        } else if (typeof item === 'object' && item['@type']) {
          rdf += `    <schema:${key}>\n`;
          rdf += `      <schema:${item['@type']}>\n`;
          Object.entries(item).forEach(([nestedKey, nestedValue]) => {
            if (nestedKey.startsWith('@') || !nestedValue) return;
            rdf += `        <schema:${nestedKey}>${escapeXML(String(nestedValue))}</schema:${nestedKey}>\n`;
          });
          rdf += `      </schema:${item['@type']}>\n`;
          rdf += `    </schema:${key}>\n`;
        }
      });
    }
  });

  rdf += `  </schema:${schema['@type']}>\n\n`;
  return rdf;
}

/**
 * Converts schema markup to Turtle format with comprehensive namespace declarations
 * Requirements: 2.3, 8.3
 */
export function toTurtle(schemas: SchemaMarkup[]): string {
  let turtle = `# Real Estate Agent Knowledge Graph - AI Visibility Optimization\n`;
  turtle += `# Generated by Bayon Coagent on ${new Date().toISOString()}\n\n`;
  
  // Comprehensive namespace declarations
  turtle += `@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\n`;
  turtle += `@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .\n`;
  turtle += `@prefix schema: <https://schema.org/> .\n`;
  turtle += `@prefix owl: <http://www.w3.org/2002/07/owl#> .\n`;
  turtle += `@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .\n`;
  turtle += `@prefix foaf: <http://xmlns.com/foaf/0.1/> .\n`;
  turtle += `@prefix dc: <http://purl.org/dc/elements/1.1/> .\n`;
  turtle += `@prefix dcterms: <http://purl.org/dc/terms/> .\n`;
  turtle += `@prefix geo: <http://www.w3.org/2003/01/geo/wgs84_pos#> .\n`;
  turtle += `@prefix vcard: <http://www.w3.org/2006/vcard/ns#> .\n`;
  turtle += `@prefix agent: <https://agent.example.com/> .\n\n`;

  // Add ontology metadata
  turtle += `# Ontology Metadata\n`;
  turtle += `<> a owl:Ontology ;\n`;
  turtle += `   rdfs:label "Real Estate Agent Knowledge Graph" ;\n`;
  turtle += `   rdfs:comment "AI Visibility Optimization Schema Markup for Real Estate Agents" ;\n`;
  turtle += `   owl:imports <https://schema.org/> ;\n`;
  turtle += `   dcterms:created "${new Date().toISOString()}"^^xsd:dateTime ;\n`;
  turtle += `   dcterms:creator "Bayon Coagent AI Visibility System" .\n\n`;

  for (const schema of schemas) {
    turtle += schemaToTurtle(schema);
    turtle += '\n';
  }

  return turtle;
}

/**
 * Converts a single schema to Turtle format
 */
function schemaToTurtle(schema: SchemaMarkup): string {
  const id = schema['@id'] || `<#${schema['@type'].toLowerCase()}>`;
  let turtle = `${id} a schema:${schema['@type']} ;\n`;

  const properties: string[] = [];

  Object.entries(schema).forEach(([key, value]) => {
    if (key.startsWith('@') || !value) return;

    if (typeof value === 'string') {
      properties.push(`  schema:${key} "${escapeTurtle(value)}"`);
    } else if (typeof value === 'number') {
      properties.push(`  schema:${key} ${value}`);
    } else if (typeof value === 'object' && !Array.isArray(value)) {
      // Nested object - create blank node
      if (value['@type']) {
        let nestedProps: string[] = [];
        Object.entries(value).forEach(([nestedKey, nestedValue]) => {
          if (nestedKey.startsWith('@') || !nestedValue) return;
          if (typeof nestedValue === 'string') {
            nestedProps.push(`    schema:${nestedKey} "${escapeTurtle(nestedValue)}"`);
          } else {
            nestedProps.push(`    schema:${nestedKey} ${nestedValue}`);
          }
        });
        properties.push(`  schema:${key} [ a schema:${value['@type']} ;\n${nestedProps.join(' ;\n')} ]`);
      }
    } else if (Array.isArray(value)) {
      // Array of values
      value.forEach(item => {
        if (typeof item === 'string') {
          properties.push(`  schema:${key} "${escapeTurtle(item)}"`);
        } else if (typeof item === 'object' && item['@type']) {
          let nestedProps: string[] = [];
          Object.entries(item).forEach(([nestedKey, nestedValue]) => {
            if (nestedKey.startsWith('@') || !nestedValue) return;
            if (typeof nestedValue === 'string') {
              nestedProps.push(`    schema:${nestedKey} "${escapeTurtle(nestedValue)}"`);
            } else {
              nestedProps.push(`    schema:${nestedKey} ${nestedValue}`);
            }
          });
          properties.push(`  schema:${key} [ a schema:${item['@type']} ;\n${nestedProps.join(' ;\n')} ]`);
        }
      });
    }
  });

  turtle += properties.join(' ;\n');
  turtle += ' .\n';

  return turtle;
}

/**
 * Converts schema markup to Microdata format
 */
export function toMicrodata(schemas: SchemaMarkup[]): string {
  let html = '';

  for (const schema of schemas) {
    html += schemaToMicrodata(schema);
    html += '\n';
  }

  return html;
}

/**
 * Converts a single schema to Microdata format
 */
function schemaToMicrodata(schema: SchemaMarkup): string {
  const itemType = `https://schema.org/${schema['@type']}`;
  let html = `<div itemscope itemtype="${itemType}">\n`;

  Object.entries(schema).forEach(([key, value]) => {
    if (key.startsWith('@') || !value) return;

    if (typeof value === 'string') {
      if (key === 'url' || key === 'email') {
        html += `  <a href="${escapeHTML(value)}" itemprop="${key}">${escapeHTML(value)}</a>\n`;
      } else {
        html += `  <span itemprop="${key}">${escapeHTML(value)}</span>\n`;
      }
    } else if (typeof value === 'object' && !Array.isArray(value)) {
      // Nested object
      if (value['@type']) {
        html += `  <div itemprop="${key}" itemscope itemtype="https://schema.org/${value['@type']}">\n`;
        Object.entries(value).forEach(([nestedKey, nestedValue]) => {
          if (nestedKey.startsWith('@') || !nestedValue) return;
          html += `    <span itemprop="${nestedKey}">${escapeHTML(String(nestedValue))}</span>\n`;
        });
        html += `  </div>\n`;
      }
    } else if (Array.isArray(value)) {
      // Array of values
      value.forEach(item => {
        if (typeof item === 'string') {
          html += `  <span itemprop="${key}">${escapeHTML(item)}</span>\n`;
        } else if (typeof item === 'object' && item['@type']) {
          html += `  <div itemprop="${key}" itemscope itemtype="https://schema.org/${item['@type']}">\n`;
          Object.entries(item).forEach(([nestedKey, nestedValue]) => {
            if (nestedKey.startsWith('@') || !nestedValue) return;
            html += `    <span itemprop="${nestedKey}">${escapeHTML(String(nestedValue))}</span>\n`;
          });
          html += `  </div>\n`;
        }
      });
    }
  });

  html += `</div>`;
  return html;
}

/**
 * Generates implementation instructions
 */
export function generateImplementationInstructions(formats: ExportFormat[]): string {
  let instructions = `# Schema Markup Implementation Guide\n\n`;
  
  instructions += `## Overview\n`;
  instructions += `This package contains your AI visibility schema markup in multiple formats. `;
  instructions += `Choose the format that best fits your website platform and technical requirements.\n\n`;

  if (formats.includes('json-ld')) {
    instructions += `## JSON-LD Implementation\n`;
    instructions += `JSON-LD is the recommended format by Google and most search engines.\n\n`;
    instructions += `### WordPress\n`;
    instructions += `1. Install a JSON-LD plugin like "Schema & Structured Data for WP"\n`;
    instructions += `2. Copy the JSON-LD code from the export\n`;
    instructions += `3. Paste it into the plugin's custom schema section\n\n`;
    instructions += `### HTML Pages\n`;
    instructions += `Add the JSON-LD script tag to your page's <head> section:\n`;
    instructions += `\`\`\`html\n<script type="application/ld+json">\n[JSON-LD content here]\n</script>\`\`\`\n\n`;
  }

  if (formats.includes('microdata')) {
    instructions += `## Microdata Implementation\n`;
    instructions += `Microdata is embedded directly in your HTML content.\n\n`;
    instructions += `### Integration\n`;
    instructions += `1. Replace existing content sections with the microdata HTML\n`;
    instructions += `2. Ensure the content is visible to users\n`;
    instructions += `3. Test with Google's Rich Results Test tool\n\n`;
  }

  if (formats.includes('rdf-xml') || formats.includes('turtle')) {
    instructions += `## RDF Implementation\n`;
    instructions += `RDF formats are useful for semantic web applications and knowledge graphs.\n\n`;
    instructions += `### Usage\n`;
    instructions += `1. Upload RDF files to your website's semantic data directory\n`;
    instructions += `2. Reference them in your site's metadata\n`;
    instructions += `3. Use for AI system integration and data exchange\n\n`;
  }

  instructions += `## Validation\n`;
  instructions += `Always validate your schema markup after implementation:\n`;
  instructions += `- Google Rich Results Test: https://search.google.com/test/rich-results\n`;
  instructions += `- Schema.org Validator: https://validator.schema.org/\n`;
  instructions += `- Structured Data Testing Tool: https://search.google.com/structured-data/testing-tool\n\n`;

  instructions += `## Best Practices\n`;
  instructions += `1. Keep schema markup up-to-date with your profile changes\n`;
  instructions += `2. Use specific, accurate information\n`;
  instructions += `3. Include all relevant properties for better AI understanding\n`;
  instructions += `4. Monitor for validation errors regularly\n`;
  instructions += `5. Test across different AI platforms\n\n`;

  return instructions;
}

/**
 * Generates platform-specific implementation guides
 */
export function generatePlatformGuides(): Record<string, string> {
  return {
    wordpress: `# WordPress Implementation Guide

## Recommended Plugins
- **Schema & Structured Data for WP**: Best for JSON-LD
- **WP SEO Structured Data Schema**: Alternative option
- **All in One SEO**: Has built-in schema support

## Implementation Steps
1. Install and activate a schema plugin
2. Navigate to the plugin's settings
3. Add custom schema markup using the JSON-LD export
4. Configure automatic updates for profile changes
5. Test with Google's Rich Results Test

## Custom Theme Integration
If you prefer manual implementation:
1. Add JSON-LD to your theme's header.php
2. Use WordPress hooks to inject schema dynamically
3. Create custom fields for schema properties`,

    squarespace: `# Squarespace Implementation Guide

## JSON-LD Implementation
1. Go to Settings > Advanced > Code Injection
2. Add the JSON-LD script to the Header section
3. Save changes and test the implementation

## Page-Specific Schema
1. Edit the specific page
2. Go to Settings > Advanced
3. Add JSON-LD to Page Header Code Injection
4. Save and publish changes

## Limitations
- Squarespace doesn't support microdata editing
- Use JSON-LD format exclusively
- Test thoroughly after implementation`,

    shopify: `# Shopify Implementation Guide

## Theme Integration
1. Access your theme's code editor
2. Edit the theme.liquid file
3. Add JSON-LD script to the <head> section
4. Save changes

## App-Based Solutions
- **JSON-LD for SEO**: Automated schema management
- **TinyIMG**: Includes schema markup features
- **SearchPie**: Comprehensive SEO with schema

## Product Schema
For e-commerce specific schema:
1. Use product-specific JSON-LD
2. Include pricing and availability
3. Add review schema for testimonials`,

    wix: `# Wix Implementation Guide

## Custom Code Integration
1. Go to Settings > Custom Code
2. Add new custom code
3. Paste JSON-LD script
4. Set to load on all pages or specific pages
5. Save and publish

## Wix SEO Wiz
1. Use Wix's built-in SEO tools
2. Add structured data through SEO settings
3. Customize for real estate specific needs

## Limitations
- Limited microdata support
- Focus on JSON-LD implementation
- Test with Wix's preview tools`,

    webflow: `# Webflow Implementation Guide

## Custom Code Implementation
1. Go to Project Settings > Custom Code
2. Add JSON-LD to Head Code section
3. Publish changes

## Page-Specific Schema
1. Select the page in the Designer
2. Go to Page Settings > Custom Code
3. Add JSON-LD to Head Code
4. Publish changes

## Dynamic Content
1. Use Webflow's CMS for dynamic schema
2. Bind schema properties to CMS fields
3. Create templates for different content types`,

    html: `# Static HTML Implementation Guide

## JSON-LD Implementation
Add to your HTML <head> section:
\`\`\`html
<script type="application/ld+json">
[Your JSON-LD content here]
</script>
\`\`\`

## Microdata Implementation
Replace existing content with microdata-enhanced HTML:
\`\`\`html
<div itemscope itemtype="https://schema.org/RealEstateAgent">
  <span itemprop="name">Your Name</span>
  <!-- Additional properties -->
</div>
\`\`\`

## Best Practices
1. Validate HTML after adding schema
2. Use semantic HTML structure
3. Keep schema close to related content
4. Test across different browsers`
  };
}

/**
 * Creates a complete export package with all formats and guides
 * Requirements: 8.1, 8.2, 8.3, 8.4, 8.5
 */
export function createExportPackage(
  schemas: SchemaMarkup[],
  formats: ExportFormat[] = ['json-ld', 'rdf-xml', 'turtle', 'microdata'],
  options: {
    validateRDF?: boolean;
    includeMetadata?: boolean;
  } = {}
): ExportPackage & { 
  validation?: {
    isValid: boolean;
    errors: string[];
    warnings: string[];
    suggestions: string[];
  }
} {
  const exportPackage = {
    jsonLD: toJSONLD(schemas),
    rdfXML: toRDFXML(schemas),
    turtle: toTurtle(schemas),
    microdata: toMicrodata(schemas),
    instructions: generateImplementationInstructions(formats),
    platformGuides: generatePlatformGuides(),
  };

  // Add RDF validation if requested
  if (options.validateRDF && (formats.includes('rdf-xml') || formats.includes('turtle'))) {
    // Convert schemas to triples for validation
    const triples: RDFTriple[] = [];
    
    for (const schema of schemas) {
      const subject = schema['@id'] || `#${schema['@type'].toLowerCase()}`;
      
      // Add type triple
      triples.push({
        subject,
        predicate: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',
        object: `https://schema.org/${schema['@type']}`,
      });

      // Add property triples
      Object.entries(schema).forEach(([key, value]) => {
        if (key.startsWith('@') || !value) return;
        
        const predicate = `https://schema.org/${key}`;
        
        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
          triples.push({ subject, predicate, object: value });
        } else if (Array.isArray(value)) {
          value.forEach(item => {
            if (typeof item === 'string') {
              triples.push({ subject, predicate, object: item });
            }
          });
        }
      });
    }

    const validation = validateRDFTriples(triples);
    return { ...exportPackage, validation };
  }

  return exportPackage;
}

/**
 * Validates RDF triples for semantic correctness
 * Requirements: 2.3
 */
export function validateRDFTriples(triples: RDFTriple[]): {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  suggestions: string[];
} {
  const errors: string[] = [];
  const warnings: string[] = [];
  const suggestions: string[] = [];

  // Check for empty triples
  if (triples.length === 0) {
    warnings.push('No RDF triples found to validate');
    return { isValid: true, errors, warnings, suggestions };
  }

  // Validate each triple
  for (let i = 0; i < triples.length; i++) {
    const triple = triples[i];
    const tripleRef = `Triple ${i + 1}`;

    // Validate subject
    if (!triple.subject || typeof triple.subject !== 'string') {
      errors.push(`${tripleRef}: Subject is required and must be a string`);
    } else if (!isValidURI(triple.subject) && !isValidBlankNode(triple.subject)) {
      errors.push(`${tripleRef}: Subject must be a valid URI or blank node`);
    }

    // Validate predicate
    if (!triple.predicate || typeof triple.predicate !== 'string') {
      errors.push(`${tripleRef}: Predicate is required and must be a string`);
    } else if (!isValidURI(triple.predicate)) {
      errors.push(`${tripleRef}: Predicate must be a valid URI`);
    }

    // Validate object
    if (triple.object === undefined || triple.object === null) {
      errors.push(`${tripleRef}: Object is required`);
    }

    // Check for Schema.org compliance
    if (triple.predicate && triple.predicate.includes('schema.org')) {
      if (!isValidSchemaProperty(triple.predicate)) {
        warnings.push(`${tripleRef}: Property ${triple.predicate} may not be a valid Schema.org property`);
      }
    }
  }

  // Check for duplicate triples
  const tripleStrings = triples.map(t => `${t.subject} ${t.predicate} ${t.object}`);
  const duplicates = tripleStrings.filter((item, index) => tripleStrings.indexOf(item) !== index);
  if (duplicates.length > 0) {
    warnings.push(`Found ${duplicates.length} duplicate triples`);
  }

  // Check for orphaned entities
  const subjects = new Set(triples.map(t => t.subject));
  const objects = new Set(triples.map(t => typeof t.object === 'string' ? t.object : '').filter(Boolean));
  
  Array.from(objects).forEach(obj => {
    if (isValidURI(obj) && !subjects.has(obj)) {
      suggestions.push(`Object ${obj} is referenced but not defined as a subject`);
    }
  });

  return {
    isValid: errors.length === 0,
    errors,
    warnings,
    suggestions,
  };
}

/**
 * Checks if a string is a valid URI
 */
function isValidURI(uri: string): boolean {
  try {
    new URL(uri);
    return true;
  } catch {
    return uri.startsWith('_:') || uri.includes(':'); // Allow relative URIs and blank nodes
  }
}

/**
 * Checks if a string is a valid blank node
 */
function isValidBlankNode(node: string): boolean {
  return node.startsWith('_:');
}

/**
 * Checks if a predicate is a valid Schema.org property
 */
function isValidSchemaProperty(predicate: string): boolean {
  // Basic check for Schema.org properties
  const schemaProperties = [
    'name', 'description', 'url', 'email', 'telephone', 'address',
    'geo', 'sameAs', 'knowsAbout', 'areaServed', 'aggregateRating',
    'review', 'memberOf', 'hasCredential', 'specialization', 'agentType',
    'latitude', 'longitude', 'streetAddress', 'addressLocality',
    'addressRegion', 'postalCode', 'addressCountry', 'ratingValue',
    'reviewCount', 'author', 'reviewRating', 'reviewBody', 'datePublished'
  ];
  
  const propertyName = predicate.split('/').pop() || '';
  return schemaProperties.includes(propertyName);
}

/**
 * Converts RDF triples to RDF/XML format
 * Requirements: 8.3
 */
export function triplesToRDFXML(triples: RDFTriple[]): string {
  const namespaces = `
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
    xmlns:schema="https://schema.org/"
    xmlns:owl="http://www.w3.org/2002/07/owl#"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema#"
  `.trim();

  let rdfContent = `<?xml version="1.0" encoding="UTF-8"?>\n`;
  rdfContent += `<rdf:RDF ${namespaces}>\n\n`;

  // Group triples by subject
  const subjectGroups = new Map<string, RDFTriple[]>();
  for (const triple of triples) {
    if (!subjectGroups.has(triple.subject)) {
      subjectGroups.set(triple.subject, []);
    }
    subjectGroups.get(triple.subject)!.push(triple);
  }

  // Generate RDF/XML for each subject
  Array.from(subjectGroups.entries()).forEach(([subject, subjectTriples]) => {
    rdfContent += `  <rdf:Description rdf:about="${escapeXML(subject)}">\n`;
    
    for (const triple of subjectTriples) {
      const predicate = getLocalName(triple.predicate);
      const namespace = getNamespace(triple.predicate);
      
      if (typeof triple.object === 'string' && isValidURI(triple.object)) {
        rdfContent += `    <${predicate} rdf:resource="${escapeXML(triple.object)}"/>\n`;
      } else {
        const datatype = typeof triple.object === 'number' ? ' rdf:datatype="xsd:decimal"' : '';
        rdfContent += `    <${predicate}${datatype}>${escapeXML(String(triple.object))}</${predicate}>\n`;
      }
    }
    
    rdfContent += `  </rdf:Description>\n\n`;
  });

  rdfContent += `</rdf:RDF>\n`;
  return rdfContent;
}

/**
 * Converts RDF triples to Turtle format
 * Requirements: 8.3
 */
export function triplesToTurtle(triples: RDFTriple[]): string {
  let turtle = `# RDF Triples Export\n`;
  turtle += `# Generated by Bayon Coagent on ${new Date().toISOString()}\n\n`;
  
  turtle += `@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\n`;
  turtle += `@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .\n`;
  turtle += `@prefix schema: <https://schema.org/> .\n`;
  turtle += `@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .\n\n`;

  // Group triples by subject
  const subjectGroups = new Map<string, RDFTriple[]>();
  for (const triple of triples) {
    if (!subjectGroups.has(triple.subject)) {
      subjectGroups.set(triple.subject, []);
    }
    subjectGroups.get(triple.subject)!.push(triple);
  }

  // Generate Turtle for each subject
  Array.from(subjectGroups.entries()).forEach(([subject, subjectTriples]) => {
    turtle += `<${subject}>\n`;
    
    subjectTriples.forEach((triple, index) => {
      const predicate = `<${triple.predicate}>`;
      let object: string;
      
      if (typeof triple.object === 'string' && isValidURI(triple.object)) {
        object = `<${triple.object}>`;
      } else if (typeof triple.object === 'number') {
        object = String(triple.object);
      } else {
        object = `"${escapeTurtle(String(triple.object))}"`;
      }
      
      const separator = index === subjectTriples.length - 1 ? ' .' : ' ;';
      turtle += `    ${predicate} ${object}${separator}\n`;
    });
    
    turtle += '\n';
  });

  return turtle;
}

/**
 * Utility functions for escaping content in different formats
 */
function escapeXML(text: string): string {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function escapeHTML(text: string): string {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

function escapeTurtle(text: string): string {
  return text
    .replace(/\\/g, '\\\\')
    .replace(/"/g, '\\"')
    .replace(/\n/g, '\\n')
    .replace(/\r/g, '\\r')
    .replace(/\t/g, '\\t');
}

/**
 * Gets the local name from a URI
 */
function getLocalName(uri: string): string {
  const parts = uri.split(/[/#]/);
  return parts[parts.length - 1];
}

/**
 * Gets the namespace from a URI
 */
function getNamespace(uri: string): string {
  const lastSlash = uri.lastIndexOf('/');
  const lastHash = uri.lastIndexOf('#');
  const splitIndex = Math.max(lastSlash, lastHash);
  return splitIndex > 0 ? uri.substring(0, splitIndex + 1) : uri;
}